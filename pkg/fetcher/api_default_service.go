/*
 * jessemichael.me internal
 *
 * Internal workings of Jesse Michael
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package fetcher

import (
	"fmt"
	"log"
	"strconv"
	"time"

	"github.com/dghubble/go-twitter/twitter"
)

// DefaultApiService is a service that implents the logic for the DefaultApiServicer
// This service should implement the business logic for every endpoint for the DefaultApi API.
// Include any external packages or services that will be required by this service.
type DefaultApiService struct {
	tClient *twitter.Client
}

// NewDefaultApiService creates a default api service
func NewDefaultApiService(twitterClient *twitter.Client) DefaultApiServicer {
	return &DefaultApiService{
		tClient: twitterClient,
	}
}

// GetFeed - Get feed
func (s *DefaultApiService) GetFeed(twitterID string) (interface{}, error) {
	items := []FeedItem{}
	twitterItems, err := s.getTwitter(twitterID)
	if err != nil {
		log.Printf("error retrieving twitter items. err: %s\n", err)
	}

	items = append(items, twitterItems...)
	return FeedItems{Items: items}, nil
}

func (s *DefaultApiService) getTwitter(twitterID string) ([]FeedItem, error) {
	if s.tClient == nil {
		return nil, nil
	}

	id, err := strconv.Atoi(twitterID)
	if err != nil {
		return nil, err
	}

	excludeReplies := false
	includeRetweets := true
	trimUser := false
	timeline := &twitter.UserTimelineParams{
		UserID:          int64(id),
		Count:           20,
		ExcludeReplies:  &excludeReplies,
		IncludeRetweets: &includeRetweets,
		TrimUser:        &trimUser,
	}

	tweets, _, err := s.tClient.Timelines.UserTimeline(timeline)
	if err != nil {
		return nil, err
	}

	items := []FeedItem{}
	for _, tweet := range tweets {
		tweetURL := fmt.Sprintf("https://twitter.com/%s/status/%s", tweet.User.ScreenName, tweet.IDStr)
		author := fmt.Sprintf("<a href='%s' style='text-decoration: none' target='_top'><img class='twitter-avatar' src='%s'> %s: </a>", tweetURL, tweet.User.ProfileImageURL, tweet.User.ScreenName)
		media := ""
		if len(tweet.Entities.Media) > 0 {
			media = "<br/><div class='twitter-media'>"
			for _, m := range tweet.Entities.Media {
				media += fmt.Sprintf("<a href='%s'  target='_top'><img class='content-media' src = '%s'.png'></a>", m.URLEntity.URL, m.MediaURL)
			}
			media += "</div>"
		}
		ts, _ := time.Parse(time.RFC3339, tweet.CreatedAt)
		item := FeedItem{
			Id:      tweet.IDStr,
			Ts:      int32(ts.Unix()),
			Source:  "twitter",
			Url:     "",
			Media:   "",
			Content: author + tweet.Text + media,
		}
		items = append(items, item)
	}
	return items, nil
}
