/*
 * jessemichael.me internal
 *
 * Internal workings of Jesse Michael
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package fetcher

import (
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"sort"
	"strconv"
	"time"

	"github.com/ahmdrz/goinsta/v2"
	"github.com/dghubble/go-twitter/twitter"
	"github.com/tidwall/gjson"
)

const (
	count = 20
)

// DefaultApiService is a service that implents the logic for the DefaultApiServicer
// This service should implement the business logic for every endpoint for the DefaultApi API.
// Include any external packages or services that will be required by this service.
type DefaultApiService struct {
	tClient *twitter.Client
	iClient *goinsta.Instagram
}

// NewDefaultApiService creates a default api service
func NewDefaultApiService(twitterClient *twitter.Client, insta *goinsta.Instagram) DefaultApiServicer {
	return &DefaultApiService{
		tClient: twitterClient,
		iClient: insta,
	}
}

// GetFeed - Get feed
func (s *DefaultApiService) GetFeed(twitterID, instagramID, bloggerID string) (interface{}, error) {
	items := []FeedItem{}
	twitterItems, err := s.getTwitter(twitterID)
	if err != nil {
		log.Printf("error retrieving twitter items. err: %s\n", err)
	}

	instagramItems, err := s.getInstagram(instagramID)
	if err != nil {
		log.Printf("error retrieving instagram items. err: %s\n", err)
	}

	bloggerItems, err := s.getBlogger(bloggerID)
	if err != nil {
		log.Printf("error retrieving blogger items. err: %s\n", err)
	}

	items = append(items, twitterItems...)
	items = append(items, instagramItems...)
	items = append(items, bloggerItems...)

	sort.SliceStable(items, func(i, j int) bool {
		return items[i].Ts > items[j].Ts
	})
	return FeedItems{Items: items}, nil
}

func (s *DefaultApiService) getTwitter(twitterID string) ([]FeedItem, error) {
	if s.tClient == nil {
		return nil, nil
	}

	id, err := strconv.ParseInt(twitterID, 10, 64)
	if err != nil {
		return nil, err
	}

	excludeReplies := false
	includeRetweets := true
	trimUser := false
	timeline := &twitter.UserTimelineParams{
		UserID:          id,
		Count:           count,
		ExcludeReplies:  &excludeReplies,
		IncludeRetweets: &includeRetweets,
		TrimUser:        &trimUser,
		TweetMode:       "extended",
	}

	tweets, _, err := s.tClient.Timelines.UserTimeline(timeline)
	if err != nil {
		return nil, err
	}

	items := []FeedItem{}
	for _, tweet := range tweets {
		tweetURL := fmt.Sprintf("https://twitter.com/%s/status/%s", tweet.User.ScreenName, tweet.IDStr)
		author := fmt.Sprintf("<a href='%s' style='text-decoration: none' target='_top'><img class='twitter-avatar' src='%s'> %s: </a>", tweetURL, tweet.User.ProfileImageURL, tweet.User.ScreenName)
		media := ""
		if len(tweet.Entities.Media) > 0 {
			media = "<br/><div class='twitter-media'>"
			for _, m := range tweet.Entities.Media {
				media += fmt.Sprintf("<a href='%s'  target='_top'><img class='content-media' src = '%s'.png'></a>", m.URLEntity.URL, m.MediaURL)
			}
			media += "</div>"
		}
		ts, _ := time.Parse(time.RubyDate, tweet.CreatedAt)
		item := FeedItem{
			Id:      tweet.IDStr,
			Ts:      ts.Unix(),
			Source:  "twitter",
			Url:     tweetURL,
			Media:   []FeedItemMedia{},
			Content: author + tweet.FullText + media,
		}
		items = append(items, item)
	}
	return items, nil
}

func (s *DefaultApiService) getInstagram(instagramID string) ([]FeedItem, error) {
	if s.iClient == nil {
		return nil, nil
	}

	id, err := strconv.ParseInt(instagramID, 10, 64)
	if err != nil {
		return nil, err
	}

	res, err := s.iClient.Profiles.ByID(id)
	if err != nil {
		return nil, err
	}
	f := res.Feed()
	f.Next()

	items := []FeedItem{}
	for _, media := range f.Items {
		medias := getInstagramMedia(media)

		item := FeedItem{
			Id:      media.ID,
			Ts:      media.TakenAt,
			Source:  "instagram",
			Url:     fmt.Sprintf("https://www.instagram.com/p/%s", media.Code),
			Media:   medias,
			Content: media.Caption.Text,
		}
		items = append(items, item)
	}

	return items, nil
}

func getInstagramMedia(media goinsta.Item) []FeedItemMedia {
	medias := []FeedItemMedia{}
	if len(media.CarouselMedia) > 0 {
		for _, c := range media.CarouselMedia {
			medias = append(medias, getInstagramMedia(c)...)
		}
	}

	if len(media.Videos) > 0 {
		medias = append(medias, FeedItemMedia{
			Url:    media.Videos[0].URL,
			Poster: media.Images.GetBest(),
			Kind:   "video",
		})
	} else {
		medias = append(medias, FeedItemMedia{
			Url:  media.Images.GetBest(),
			Kind: "image",
		})
	}

	return medias
}

func (s *DefaultApiService) getBlogger(bloggerID string) ([]FeedItem, error) {
	if s.tClient == nil {
		return nil, nil
	}

	req, err := http.NewRequest(http.MethodGet, fmt.Sprintf("https://www.googleapis.com/blogger/v2/blogs/%s/posts", bloggerID), nil)
	if err != nil {
		return nil, err
	}
	q := url.Values{}
	q.Add("key", "AIzaSyBU3_KGZO90Vu_s8Lhbl7lJAEsaIouAEaY")
	q.Add("fetchBodies", "true")
	q.Add("maxResults", "20")
	req.URL.RawQuery = q.Encode()

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	fmt.Println(string(body))

	items := []FeedItem{}
	for _, blog := range gjson.Get(string(body), "items").Array() {
		time, err := time.Parse(time.RFC3339, blog.Get("published").String())
		if err != nil {
			return nil, err
		}
		item := FeedItem{
			Id:      blog.Get("id").String(),
			Ts:      time.Unix(),
			Source:  "blogger",
			Url:     blog.Get("url").String(),
			Content: blog.Get("content").String(),
		}
		items = append(items, item)
	}
	return items, nil
}
